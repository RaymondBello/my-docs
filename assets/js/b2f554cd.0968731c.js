"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[477],{10:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"4","metadata":{"permalink":"/blog/4","editUrl":"https://github.com/RaymondBello/raymondbello.github.io/tree/main/blog/blog/2021-09-22-0x04.md","source":"@site/blog/2021-09-22-0x04.md","title":"Bits&Bytes-0x04","description":"Matek inspired this...","date":"2021-09-22T00:00:00.000Z","formattedDate":"September 22, 2021","tags":[{"label":"electronics","permalink":"/blog/tags/electronics"},{"label":"flight-control","permalink":"/blog/tags/flight-control"},{"label":"embedded-systems","permalink":"/blog/tags/embedded-systems"},{"label":"pcb","permalink":"/blog/tags/pcb"}],"readingTime":1.04,"truncated":false,"authors":[{"name":"Ray Bello","title":"E.E Engineer","url":"https://rayb.tech","imageURL":"https://avatars.githubusercontent.com/u/61327086?s=400&u=a272b1f5bd6fe11ae11a33668b4b469864bdc003&v=4"}],"nextItem":{"title":"Bits&Bytes-0x03","permalink":"/blog/3"}},"content":"## Matek inspired this...\\n\\nI\'ve spent alot of time thinking about an ideal size for my final PCB.\\nThere are currently some contraints that should be taken into account when planning on minimizing cost, maximazing flexibility and adhereing to airframe dimensions.\\n\\nI have been doing some research on this topic and I\'ve found that there seems to be a widespread agreement on what an ideal size should be for an onboard flight control system (amongst hobbyists and commercially).\\n\\nMatekSys have made numerous flight control boards over the years so its safe to say their designs have been tried and true especially in the hobbyist community. The F405 Wing is probably one of their most popular boards. And I happen to own a couple F405\'s myself.\\n\\n| ![img](http://www.mateksys.com/wp-content/uploads/2018/06/F411-WING_3.jpg) |\\n| :----------------------------------------------------------: |\\n|             F405 Wing (left), F411 Wing (right)              |\\n\\n## Small Big Brother\\n\\nThe F411 Wing is the smaller updated version of the F405 board with all the essentials included. I don\'t own one but I plan on using a layout very similar to the F411 in my own design. The peripherals, connector and solder pad placement are some of the main traits that I plan on trying to carry over into my own design.\\n\\nUpdates to follow..."},{"id":"3","metadata":{"permalink":"/blog/3","editUrl":"https://github.com/RaymondBello/raymondbello.github.io/tree/main/blog/blog/2021-09-03-0x03.md","source":"@site/blog/2021-09-03-0x03.md","title":"Bits&Bytes-0x03","description":"IMU Configuration","date":"2021-09-03T00:00:00.000Z","formattedDate":"September 3, 2021","tags":[{"label":"electronics","permalink":"/blog/tags/electronics"},{"label":"flight-control","permalink":"/blog/tags/flight-control"},{"label":"embedded-systems","permalink":"/blog/tags/embedded-systems"}],"readingTime":1.775,"truncated":false,"authors":[{"name":"Ray Bello","title":"E.E Engineer","url":"https://rayb.tech","imageURL":"https://avatars.githubusercontent.com/u/61327086?s=400&u=a272b1f5bd6fe11ae11a33668b4b469864bdc003&v=4"}],"prevItem":{"title":"Bits&Bytes-0x04","permalink":"/blog/4"},"nextItem":{"title":"Bits&Bytes-0x02","permalink":"/blog/2"}},"content":"## IMU Configuration\\n\\n### Sequence\\n\\nAdded a step to select the internal 8Mhz oscillator as the clock source\\n\\n``` c\\n// Set MPU9250 Clock Source to use the X Gyro for reference, which is slightly better than the default internal clock source.\\n// +-----+-----+-----+-----+-----+-----+-----+-----+\\n// |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |\\n// +-----+-----+-----+-----+-----+-----+-----+-----+\\n// |     |     |     |     |     |   CLKSEL[2:0]   |\\n// +-----+-----+-----+-----+-----+-----+-----+-----+\\nuint8_t buf[2] = {MPU9250_RA_PWR_MGMT_1, MPU9250_CLOCK_PLL_XGYRO};\\ni2c_write_blocking(i2c_default, this->i2c_addr, buf, 2, false);\\n#if defined IMU_VERBOSE_CONFIG\\n    printf(\\"[IMU][CONFIG] wrote %d to MPU9250_RA_PWR_MGMT_1:%d\\\\n\\", buf[1], MPU9250_RA_PWR_MGMT_1);\\n#endif\\nsleep_ms(DELAY_BETWEEN_WR_MS);\\n```\\n\\nAdded full scale range sensitivity selection for both accelerometer and gyroscope. \\n\\n``` c\\n// Set Gyro full scale range\\n// +-----+-----+-----+-----+-----+-----+-----+-----+\\n// |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |\\n// +-----+-----+-----+-----+-----+-----+-----+-----+\\n// |     |     |     |FS_SEL[1:0]|     |     |     |\\n// +-----+-----+-----+-----+-----+-----+-----+-----+\\nbuf[0] = MPU9250_GYRO_CONFIG;\\nbuf[1] = (uint8_t)setting.gyro_fs_sel << 3;\\ni2c_write_blocking(i2c_default, this->i2c_addr, buf, 2, false);\\n#if defined IMU_VERBOSE_CONFIG\\n    printf(\\"[IMU][CONFIG] wrote %d to MPU9250_GYRO_CONFIG:%d\\\\n\\", buf[1], MPU9250_GYRO_CONFIG);\\n#endif\\nsleep_ms(DELAY_BETWEEN_WR_MS);\\n\\n// Set Accel full scale range\\n// +-----+-----+-----+-----+-----+-----+-----+-----+\\n// |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |\\n// +-----+-----+-----+-----+-----+-----+-----+-----+\\n// |     |     |     |AFS_SEL[1:0]|    |     |     |\\n// +-----+-----+-----+-----+-----+-----+-----+-----+\\nbuf[0] = MPU9250_ACCEL_CONFIG;\\nbuf[1] = (uint8_t)setting.accel_fs_sel << 3;\\ni2c_write_blocking(i2c_default, this->i2c_addr, buf, 2, false);\\n#if defined IMU_VERBOSE_CONFIG\\n    printf(\\"[IMU][CONFIG] wrote %d to MPU9250_ACCEL_CONFIG:%d\\\\n\\", buf[1], MPU9250_ACCEL_CONFIG);\\n#endif\\nsleep_ms(DELAY_BETWEEN_WR_MS);\\n```\\n\\n### Validating Sequence\\n\\n``` json\\n[IMU][CONFIG] wrote 1 to MPU9250_RA_PWR_MGMT_1:107\\n[IMU][CONFIG] wrote 0 to MPU9250_GYRO_CONFIG:27 \\t\\t// GYRO_250DPS\\n[IMU][CONFIG] wrote 0 to MPU9250_ACCEL_CONFIG:28\\t\\t// ACCEL_2G\\n```\\n\\n\\n\\n## Tasks contd.\\n\\n### MPU9250 IMU Driver\\n\\n- [x] **Done**: Implement full scale range and gyro sensitivity selection, currently using default settings.\\n- [x] **Done**: Add hardware reset & calibration sequence\\n\\n### Attitude Estimation\\n\\n- [X] **Done**: Refactor the existing attitude estimation algorithm with modularity/flexibility in mind.\\n\\n## Defines Used\\n\\n```c++\\n#define DELAY_BETWEEN_WR_MS \\t\\t50        // Delay between I2C writes during configuration\\n#define MPU9250_GYRO_CONFIG \\t\\t0x1B      // Gyro FS_SEL address\\n#define MPU9250_ACCEL_CONFIG \\t\\t0x1C      // Accel AFS_SEL address\\n#define MPU9250_CLOCK_PLL_XGYRO 0x01    \\t// Xgyro pll clock \\n#define MPU9250_RA_PWR_MGMT_1 \\t0x6B      // Power management register 1 address\\n```"},{"id":"2","metadata":{"permalink":"/blog/2","editUrl":"https://github.com/RaymondBello/raymondbello.github.io/tree/main/blog/blog/2021-09-02-0x02.md","source":"@site/blog/2021-09-02-0x02.md","title":"Bits&Bytes-0x02","description":"Tasks contd.","date":"2021-09-02T00:00:00.000Z","formattedDate":"September 2, 2021","tags":[{"label":"electronics","permalink":"/blog/tags/electronics"},{"label":"flight-control","permalink":"/blog/tags/flight-control"},{"label":"embedded-systems","permalink":"/blog/tags/embedded-systems"}],"readingTime":0.235,"truncated":false,"authors":[{"name":"Ray Bello","title":"E.E Engineer","url":"https://rayb.tech","imageURL":"https://avatars.githubusercontent.com/u/61327086?s=400&u=a272b1f5bd6fe11ae11a33668b4b469864bdc003&v=4"}],"prevItem":{"title":"Bits&Bytes-0x03","permalink":"/blog/3"},"nextItem":{"title":"Bits&Bytes-0x01","permalink":"/blog/1"}},"content":"## Tasks contd.\\n\\n### MPU9250 IMU Driver\\n\\n- [X] **Completed**: Implement full scale range and gyro sensitivity selection, currently using default settings.\\n- [X] **Completed**: Add hardware reset & calibration sequence\\n\\n### Attitude Estimation\\n\\n- [X] **Completed**: Refactor the existing attitude estimation algorithm with modularity/flexibility in mind."},{"id":"1","metadata":{"permalink":"/blog/1","editUrl":"https://github.com/RaymondBello/raymondbello.github.io/tree/main/blog/blog/2021-09-01-0x01.md","source":"@site/blog/2021-09-01-0x01.md","title":"Bits&Bytes-0x01","description":"The system is currently in a stable state with regards to various sensor drivers and core flight logic.","date":"2021-09-01T00:00:00.000Z","formattedDate":"September 1, 2021","tags":[{"label":"electronics","permalink":"/blog/tags/electronics"},{"label":"flight-control","permalink":"/blog/tags/flight-control"},{"label":"embedded-systems","permalink":"/blog/tags/embedded-systems"}],"readingTime":0.355,"truncated":false,"authors":[{"name":"Ray Bello","title":"E.E Engineer","url":"https://rayb.tech","imageURL":"https://avatars.githubusercontent.com/u/61327086?s=400&u=a272b1f5bd6fe11ae11a33668b4b469864bdc003&v=4"}],"prevItem":{"title":"Bits&Bytes-0x02","permalink":"/blog/2"}},"content":"The system is currently in a stable state with regards to various sensor drivers and core flight logic.\\n*Although* there are a lot of tuning modifications that need to be added to the attitude estimation madgwick filter to make it flight worthy...\\n\\n## Current tasks\\n* MPU9250 IMU Driver \\n\\t* **In-Progress**: Implement full scale range and gyro sensitivity selection, currently using default settings.\\n\\t* **Outstanding**: Add hardware reset & calibration sequence"}]}')}}]);